---
slug: tigris-standalone-search
title: Enabling awesome search experiences with Tigris Standalone Search
description: >
  Enabling awesome search experiences with Tigris Standalone Search
keywords: [nosql search, standalone search, search engine]
authors: [leggetter]
tags: [nosql search, standalone search]
image: "./tigris-standalone-search.png"
---

<head>
  <meta name="twitter:creator" content="@leggetter" />
</head>

import tigrisConfig from "@site/tigris.config.js";

export const CloudLink = ({ text = "Tigris Cloud" }) => {
  return <a href={tigrisConfig.signupUrl}>{text}</a>;
};

Database search is okay, at best. To build awesome search experiences you need a
dedicated search product.

Earlier this month we
[released Tigris Search in BETA](/blog/tigris-database-search-sync-beta/) and
covered how it supports automatic syncronization between Tigris Database and
Tigris Search, which improves developer productivity through enabling the team
to focus on shipping features and not setting up and managing database-to-search
syncronization infrastructure.

But, you many not yet be in the position to migrate all your data over to Tigris
and you may have a more pressing need to enhance your product with a great
search experience. Or, you may not store your data in a database; maybe you've
got all your data in S3, or you've got a statically generated site driven by a
number of data files stored in your source control.

Whatever the reason, Tigris Standalone Search can help if you're looking for a
search solution.

[![Enabling awesome search experiences with Tigris Standalone Search](./tigris-standalone-search.png)](/blog/tigris-standalone-search/)

<!-- truncate -->

## Tigris Standalone Search is available with Tigris Search BETA

As part of our release of Tigris Search BETA we also made it possible for your
to take advantage of
[Tigris Search as a standalone feature](https://www.tigrisdata.com/docs/concepts/searching/#standalone-search).

Tigris Standalone Search can be used with any existing data store via
integrating with our APIs and SDKs. This gives you full control to determine
which indexes you create and maintain. Here are some examples in TypeScript that
demonstrate how to use Tigris Standalone Search. For a more in-depth example and
a demo, checkout the [search demo](#search-demo) below.

Define your Search data model:

```ts
export const CATALOG_INDEX_NAME = "catalog";

@TigrisSearchIndex(CATALOG_INDEX_NAME)
export class Catalog {
  @SearchField({ sort: true })
  name: string;

  @SearchField({ sort: true })
  price: number;

  @SearchField({ facet: true })
  brand: string;

  @SearchField({ elements: TigrisDataTypes.STRING, facet: true })
  @Field({ elements: TigrisDataTypes.STRING })
  tags: Array<string>;
}
```

Create your search index for the data model:

```ts
const client = new Tigris();
const search = client.getSearch();
const catalog = await search.createOrUpdateIndex<Catalog>(CATALOG_INDEX_NAME);
```

Insert a document in the search index:

```ts
const result = await catalog.createOne({
  name: "fiona handbag",
  price: 99.9,
  brand: "michael kors",
  tags: "purses",
});
```

That's it!

For more information including indexing multiple documents, updating indexed
documents, and deleted indexed douments, see the
[TypeScript Standalone Search docs](https://www.tigrisdata.com/docs/sdkstools/typescript/search/).

## Awesome email search demo with Resend &amp; Tigris Search {#search-demo}

To demonstrate Tigris Search we've created a demo application with Resend - an
API platform that enables developers to build, test, and deliver transactional
APIs at scale - that simulates a series of onboarding emails to be sent across
during the onboarding journey.

1. Signed up = welcome
2. After trigger X or Y amount of time = join the community
3. After trigger X or Y amount of time = request feedback

import templateSelection from "./template-selection.mp4";

<video controls style={{ width: "100%" }}>
  <source src={templateSelection} />
</video>

After sending the emails they are stored in a Tigris Search index. As the status
of the emails changes (delivered, bounced, complained, opened, clicked), Resend
triggers a webhook which updates the Tigris search index with the updated email
status. You can then search across all the attributes of an email document
within the Tigris Search index using:

- Full-text real-time search with fuzzy matching across all fields (status, to,
  from, subject, created [date], and email body)
- Filtering on email status
- Sorting by date
- Browsing via pagination

import search from "./search.mp4";

<video controls style={{ width: "100%" }}>
  <source src={search} />
</video>

It's a simple but powerful use case of Tigris standalone search.

You can try out the
[Awesome Email Search demo](https://awesome-email-search.vercel.app/), grab the
[Awesome Email Search code on GitHub](https://github.com/tigrisdata-community/awesome-email-search),
or read through the code walk-through, below.

## How to send transactional email with Resend

The demo application is building using Next.js and makes use of the
[Next.js 13 App Router](https://nextjs.org/docs/app/building-your-application/routing).

When the Send email form is submitted, a route handles the `POST` request.

```ts title=src/app/api/email/route.tsx
export async function POST(request: Request) {
  let emailIndex;
  let statusCode = 400;
  try {
    const formData = await request.formData();
    const stage = formData.get('stage');
    if (!stage) {
      throw new Error('"stage" is a required search parameter');
    }

    ...
```

In the code above we define a `emailIndex` variable represending the Tigris
Search index we're going to create and also `statusCode` variable to hold the
status code to be used in the `POST` response. We grab the form data from the
`POST` request and extract the `stage` value. `stage` maps to the email we'll
send: Welcome, Join the community, or Request feedback. The code also checks
that the stage exists.

Next, we lookup the Resend email template and create the email:

```ts title=src/app/api/email/route.tsx
    if (!stage) {
      throw new Error('"stage" is a required search parameter');
    }

    const emailTemplate = EmailTemplates[stage as string];

    if (!emailTemplate) {
      throw new Error(`Could not find email template for stage "${stage}"`);
    }

    const body = emailTemplate.template({
      name: formData.get('name')?.valueOf() as string,
      link: formData.get('link')?.valueOf() as string,
    })!;
    log('created email');

    ...
```

Here, we perform a lookup based on the `stage` value and get a reference to the
email template details. The `template` property is a react component - yep,
Resend allows you to create emails in React - and we create the body of the
email, passing in `name` and `link` values that have been submitted via the
`POST` request.

Now that we have the email contents, we can send the email:

```ts title=src/app/api/email/route.tsx
    log('created email');

    const testEmailStatus = formData.get('testEmailStatus')
      ? TestEmailStatus[
          formData.get('testEmailStatus') as unknown as TestEmailStatus
        ]
      : '';
    log(
      'testEmailStatus',
      testEmailStatus,
      `[${formData.get('testEmailStatus')}]`
    );
    const sendEmailRequest: SendEmailData = {
      from: process.env.DEFAULT_EMAIL as string,
      to: [getToEmail(testEmailStatus)],
      subject: emailTemplate.emailSubject,
      react: body,
    };
    const sendResponse = await resend.sendEmail(sendEmailRequest);
    log('sent email');
    statusCode = 201;

    ...
```

Resend provides a number of
[test email addresses](https://resend.com/docs/dashboard/emails/send-test-emails)
(e.g. `bounced@resend.dev`) you can use to test sending emails. We map the
`testEmailStatus` form data to a `to` email address via the `TestEmailStatus`
lookup, create a `SendEmailData` payload including `from`, `to`, `subject` and
`body` information, and make a request to send the email via
`await resend.sendEmail`. Finally, we set a `statusCode` variable value of `201`
to indicate the resource has been created.

## How to index emails with Tigris Search

Before we continue with the `POST` handling code, let's look at how we define
our
[Search data model](https://www.tigrisdata.com/docs/sdkstools/typescript/database/datamodel/)
and create the search index.

First, we define an `Email` class:

```ts title=src/db/models/email.ts
export const EMAIL_INDEX_NAME = "emails";

@TigrisSearchIndex(EMAIL_INDEX_NAME)
export class Email implements EmailResult {
  @SearchField({ id: true })
  id?: string;

  @SearchField({ sort: true })
  firstTo!: string;

  @SearchField({ elements: TigrisDataTypes.STRING })
  to!: string[];

  @SearchField({ sort: true })
  from!: string;

  @SearchField({ sort: true })
  subject!: string;

  @SearchField()
  body!: string;

  @SearchField({ sort: true, facet: true })
  status!: EmailStatus;

  @SearchField({ sort: true })
  createdAt!: Date;
}
```

The `Email` class defines the Search document model to be created in an index
called `email`. Fields to be indexed are marked with a `@SearchField` decorator,
if they are to be sortable `sort` is set in the decorator, if they are a
potential `facet` they are also marked as such. Where possible, data types are
inferred. Since `to` is an Array, `{ elements: TigrisDataTypes.STRING }` must be
passed to the decorator.

With the Search data model defined, we need to create the Search index:

```ts title=scripts/setup.ts
import { Email } from "../src/db/models/email";
import { Tigris } from "@tigrisdata/core";

const main = async () => {
  const client = new Tigris();
  const search = client.getSearch();
  await search.createOrUpdateIndex<Email>(Email);
};

main();
```

This simple script should be run whenever the application starts, code data
model code is changed, or the application is built. It informs Tigris of the
Search Model structure and to create a Search index via the async call to
`search.createOrUpdateIndex<Email>(Email)`.

Now that we've created the Search index, we can head back to the `POST` handling
function.

With the email sent, we can create the email document in the search index.

```ts title=src/app/api/email/route.tsx
    const sendResponse = await resend.sendEmail(sendEmailRequest);
    log('sent email');
    statusCode = 201;

    const bodyString = reactElementToJSXString(body);
    log('created body string', bodyString);

    emailIndex: Email = {
      to: sendEmailRequest.to as string[],
      firstTo: sendEmailRequest.to[0] as string,
      from: sendEmailRequest.from,
      status: EmailStatus.Pending,
      subject: emailTemplate.emailSubject,
      body: bodyString,
      createdAt: new Date(),
      id: (sendResponse as EmailResponse).id,
    };

    log('creating index', emailIndex);
    const emails = await search.getIndex<Email>(EMAIL_INDEX_NAME);
    const createResult = await emails.createOne(emailIndex);

    if (createResult.error) {
      console.error('Error occurred saving search index', createResult.error);
    } else {
      log('Index created', createResult);
    }

    ...
```

The `emailIndex` variable is assigned a structure that matches the `Email` class
data model that we've defined. We then get the `emails` index using
`await search.getIndex<Email>(EMAIL_INDEX_NAME)` and then create the email
document within the index with `await emails.createOne(emailIndex)`. Finally, we
check the result and log success or failure

:::note A `201` even if the index creation fails?

I made the decision to still return a `201` if the email is sent but the search
index insertion fails. This is an interesting point for discussion.

:::

With the email sent and the document inserted into the Search index, we return
the email index to the client if everything has gone as expected. Otherwise, we
return a status code of 400 along with the error message.

```ts title=src/app/api/email/route.tsx
    if (createResult.error) {
      console.error('Error occurred saving search index', createResult.error);
    } else {
      log('Index created', createResult);
    }
  } catch (ex: any) {
    console.error(ex);
    return NextResponse.json({ error: ex.toString() }, { status: statusCode });
  }

  return NextResponse.json(emailIndex, { status: statusCode });
}
```

Here's the what the sending experience looks like which makes use of the `POST`
endpoint:

import sendingEmail from "./sending-email.mp4";

<video controls style={{ width: "100%" }}>
  <source src={sendingEmail} />
</video>

## How to search with Tigris Search

```ts title=src/app/api/email/route.tsx
export async function GET(request: Request) {
  const response: SearchResponse = {
    results: [],
    meta: undefined,
    error: undefined,
  };
  const { searchParams } = new URL(request.url);
  log('searchParams', searchParams);
  try {
    const query = searchParams.get('search') || undefined;
    const statuses = searchParams.get('statuses') || undefined;
    const sortOrder = toSortOrder(searchParams.get('sortdir'));

    // Number(null) = 0
    const page = Number(searchParams.get('page'));
    if (page <= 0) {
      throw new Error(
        '"page" is a required search parameter and must be a number greater than 0'
      );
    }

    ...
```

```ts title=src/app/api/email/route.tsx
    const emails = await search.getIndex<Email>(EMAIL_INDEX_NAME);
    const searchQuery: SearchQuery<Email> = {
      q: query,
      hitsPerPage: PAGE_SIZE,
      sort: sortOrder,
    };
    if (statuses) {
      const orFilter: Filter<Email>[] = statuses.split(',').map((status) => {
        const enumAsStr = status as unknown as EmailStatus;
        const asEnum = EmailStatus[enumAsStr];
        log('map', status, enumAsStr, asEnum);
        return {
          status: asEnum,
        } as Filter<Email>;
      });
      if (orFilter.length > 1) {
        searchQuery.filter = {
          $or: orFilter,
        };
      } else {
        searchQuery.filter = orFilter[0];
      }
    }
    log('searchQuery', JSON.stringify(searchQuery, null, 2));
    const queryResult = await emails.search(searchQuery, page);
    log('queryResult', queryResult);

    ...
```

```ts title=src/app/api/email/route.tsx
    response.results = queryResult.hits.map((hit) => hit.document);
    response.meta = queryResult.meta;
  } catch (ex) {
    console.error(ex);
    response.error = ex as string;
  }

  return NextResponse.json(response);
}
```

## How Resend webhooks trigger Tigris Search index updates

```ts
export async function POST(request: Request) {
  let errorStatusCode = 500;
  try {
    // TODO request signing

    const body = (await request.json()) as ResendWebhook;
    log('WebHook', JSON.stringify(body, null, 2));
    const newStatus: EmailStatus = WebHookToEmailStatusLookup[body.type];
    log(`Updating status to`, newStatus);

    ...
```

```ts
    log(`Updating status to`, newStatus);

    log('getting index and document');
    const emailsIndex = await search.getIndex<Email>(EMAIL_INDEX_NAME);
    const toUpdate = await emailsIndex.getOne(body.data.email_id);
    log('found document', JSON.stringify(toUpdate, null, 2));

    if (toUpdate === undefined) {
      errorStatusCode = 404;
      throw new Error(
        `Could not find document in index for Email with id ${body.data.email_id}`
      );
    }

    ...
```

```ts
    if (toUpdate === undefined) {
      errorStatusCode = 404;
      throw new Error(
        `Could not find document in index for Email with id ${body.data.email_id}`
      );
    }

    toUpdate.document.status = newStatus;
    const updateStatus = await emailsIndex.updateOne(toUpdate.document);
    log('Update result', JSON.stringify(updateStatus, null, 2));

    if (updateStatus.error) {
      const msg = 'Error updating indexed document:' + updateStatus.error;
      console.error(msg);
      throw new Error(msg);
    }

    return NextResponse.json({}, { status: 200 });
  } catch (ex) {
    return NextResponse.json({}, { status: errorStatusCode });
  }
}
```

## Try the demo to get start with Tigris Search and Resend

Consider ending on a CTA... A few examples below:

<p>
  <CloudLink text="Sign up for a free Tigris Cloud account" /> to see the
  benefits of our serverlesss NoSQL Database and Search platform.
</p>

Have questions? <a href="https://www.tigrisdata.com/contact/">Get in touch</a>.

---

import NewsletterSubscribe from "../../src/components/NewsletterSubscribe";

<NewsletterSubscribe />
